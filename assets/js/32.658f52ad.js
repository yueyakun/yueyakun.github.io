(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{517:function(e,a,t){"use strict";t.r(a);var n=t(4),i=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Caffeine Cache 是替代 Guava Cache 的新一代缓存技术，在性能方面，Caffeine 已经全面超越 Guava。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/ben-manes/caffeine/wiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("Caffeine github 官方地址"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"常见缓存淘汰算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见缓存淘汰算法"}},[e._v("#")]),e._v(" 常见缓存淘汰算法")]),e._v(" "),t("p",[e._v("淘汰算法是缓存技术的灵魂，常见淘汰算法有以下几种：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("FIFO：先进先出，先进入先淘汰，命中率低；\nLRU：最近最少使用，把每次访问到的数据放到队尾，淘汰的时候从队首开始淘汰，没有考虑访问频率问题，并发高时可能淘汰掉真正的热点数据；\nLFU：最近最少频率使用，记录缓存中每个数据的使用频率，优先淘汰使用频率低的。如果热点数据有时效性，会出现以前的某个热点数据由于之前命中频率过高，导致一直无法淘汰，占用缓存空间的问题。\n")])])]),t("p",[e._v("以上三种淘汰算法各有各的缺点，实现成本也一个比一个高。命中率最好的 LFU 有两大弱点：")]),e._v(" "),t("blockquote",[t("ol",[t("li",[e._v("需要给每个记录维护一个频率信息，每次访问都有更新，挤占内存空间且降低性能")]),e._v(" "),t("li",[e._v("如果访问模式随时间有变，LFU 的频率信息无法随之变化，早起频繁访问但是后期不再访问的数据会一直挤占缓存空间")])])]),e._v(" "),t("p",[e._v("对应大多数应用来说，访问模式都是随时间变化的，LFU 并不适合，所以 Guava 采用的是 LRU 算法。但是 LRU 算法要实现和 LFU 算法同样的\n命中率就需要更大的缓存空间。")]),e._v(" "),t("h2",{attrs:{id:"w-tinylfu"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#w-tinylfu"}},[e._v("#")]),e._v(" W-TinyLFU")]),e._v(" "),t("p",[e._v("Caffeine Cache 为了避免上面几种算法的弱点采用了 W-TinyLFU 淘汰算法。\nW-TinyLFU 是由前 google 工程师提出的一种现代缓存技术淘汰算法，他结合了 LRU 和 LFU 的优势，避免了他们的缺点。")]),e._v(" "),t("p",[e._v("为了应对额外记录频率信息会占用空间的问题，W-TinyLFU 采用了一种叫 Count-Min Sketch 的数据结构来记录频率信息，\n从而大大缩小了记录频率信息所需的内存空间。")]),e._v(" "),t("p",[e._v("Count-Min Sketch 是一个概率数据结构（有点像布隆过滤器的一个变种），实际就是一个二维数组。\n每一行就是一个 Sketch，每个 Sketch 对应一个 hash 函数。\n每当一个 k-v 被放入缓存时，每一行的 hash 函数会将这个 key 映射成本行的一个 index，然后把对应 index 位置的数字加 1。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/posts/2020/2020-10-14-caffeine-cache-01.png",alt:""}})]),e._v(" "),t("p",[e._v("为了解决访问模式随时间变化的问题，W-TinyLFU 采用了一种 reset 操作来衰减旧数据的频率值，简单来说就是\n当缓存中的数据频率数达到某个数值之后就将所有 Sketch 上的每一个频率数据都除以 2，这样就达到了衰减频率数据的目的。")]),e._v(" "),t("h2",{attrs:{id:"使用-caffeine-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-caffeine-cache"}},[e._v("#")]),e._v(" 使用 Caffeine Cache")]),e._v(" "),t("ol",[t("li",[e._v("依赖")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<dependency>\n    <groupId>com.github.ben-manes.caffeine</groupId>\n    <artifactId>caffeine</artifactId>\n    <version>2.8.6</version>\n</dependency>\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("创建缓存")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Cache<String, Object> cache = Caffeine.newBuilder()\n    .initialCapacity(100)//初始大小\n    .maximumSize(1000)//最大数量\n    .expireAfterWrite(1800, TimeUnit.SECONDS)//过期时间\n    .build();\n")])])]),t("p",[e._v("创建参数说明：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("initialCapacity: 初始的缓存空间大小\nmaximumSize: 缓存的最大数量\nmaximumWeight: 缓存的最大权重\nexpireAfterAccess: 最后一次读或写操作后经过指定时间过期\nexpireAfterWrite: 最后一次写操作后经过指定时间过期\nrefreshAfterWrite: 创建缓存或者最近一次更新缓存后经过指定时间间隔，刷新缓存\nweakKeys: 打开key的弱引用\nweakValues：打开value的弱引用\nsoftValues：打开value的软引用\nrecordStats：开发统计功能\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[e._v("填充策略")])]),e._v(" "),t("p",[e._v("3.1 手动填充")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//填充\ncache.put("hello",value);\n//获取\ncache.get("hello");\n//手动过期\ncache.invalidate("hello");\n')])])]),t("p",[e._v("3.2 同步填充")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("LoadingCache<String, Object> cache = Caffeine.newBuilder()\n    .initialCapacity(100)//初始大小\n    .maximumSize(1000)//最大数量\n    .expireAfterWrite(1800, TimeUnit.SECONDS)//过期时间\n    .build(key->getDate(key));\n")])])]),t("p",[e._v("3.3 异步填充")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("AsyncCache<String, Object> cache = Caffeine.newBuilder()\n    .initialCapacity(100)//初始大小\n    .maximumSize(1000)//最大数量\n    .expireAfterWrite(1800, TimeUnit.SECONDS)//过期时间\n    .buildAsync(key->getDateAsync(key).get());\n")])])]),t("p",[e._v("4 Caffeine 的回收策略")]),e._v(" "),t("p",[e._v("Caffeine提供了三种回收策略")]),e._v(" "),t("p",[e._v("4.1 基于大小的回收策略")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("maximumSize：\n\nmaximumWeight：\n\n**注意：maximumSize 和 maximumWeight 不能同时设置**\n")])])]),t("p",[e._v("4.2 基于时间的回收策略")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("expireAfterAccess：在最后一次访问或者写入后开始计时，在指定的时间后过期。\n\nexpireAfterWrite：在最后一次写入缓存后开始计时，在指定的时间后过期。\n\nexpireAfter：自定义到期策略\n")])])]),t("p",[t("strong",[e._v("注意：这三种到期策略也只能选其中一个")])]),e._v(" "),t("p",[e._v("4.3 基于引用的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("weakKeys：使用弱引用存储key。如果没有其他地方对该key有强引用，那么该缓存就会被垃圾回收器回收。\n\nweakValues：使用弱引用存储value。如果没有其他地方对该value有强引用，那么该缓存就会被垃圾回收器回收。\n\nsoftValues：使用软引用存储value。当内存满了过后，软引用的对象以将使用最近最少使用(least-recently-used ) 的方式进行垃圾回收。由于使用软引用是需要等到内存满了才进行回收，所以我们通常建议给缓存配置一个使用内存的最大值。\n")])])]),t("p",[e._v("Java 中四种引用类型")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("引用类型")]),e._v(" "),t("th",[e._v("被垃圾回收的时间")]),e._v(" "),t("th",[e._v("用途")]),e._v(" "),t("th",[e._v("生成时间")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("强引用 Strong Reference")]),e._v(" "),t("td",[e._v("从来不会")]),e._v(" "),t("td",[e._v("对象的一般状态")]),e._v(" "),t("td",[e._v("JVM 停止运行时")])]),e._v(" "),t("tr",[t("td",[e._v("软引用 soft Reference")]),e._v(" "),t("td",[e._v("在内存不足时")]),e._v(" "),t("td",[e._v("对象缓存")]),e._v(" "),t("td",[e._v("在内存不足时")])]),e._v(" "),t("tr",[t("td",[e._v("弱引用 weak Reference")]),e._v(" "),t("td",[e._v("在垃圾回收时")]),e._v(" "),t("td",[e._v("对象缓存")]),e._v(" "),t("td",[e._v("gc 运行后")])]),e._v(" "),t("tr",[t("td",[e._v("虚引用 Phantom Reference")]),e._v(" "),t("td",[e._v("从来不会")]),e._v(" "),t("td",[e._v("可以用虚引用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知")]),e._v(" "),t("td",[e._v("JVM 停止运行时")])])])]),e._v(" "),t("p",[t("strong",[e._v("注意：AsyncLoadingCache 不支持弱引用和软引用，weakValues 和 softValues 不能同时使用")])]),e._v(" "),t("p",[e._v("5 移除事件监听")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('LoadingCache<String, Object> cache = Caffeine.newBuilder()\n    .initialCapacity(100)//初始大小\n    .maximumSize(1000)//最大数量\n    .expireAfterWrite(1800, TimeUnit.SECONDS)//过期时间\n    .removalListener((key, value, cause) -> log.info("key:" + key + ", value:" + value + ", 删除原因:" + cause.toString()))\n    .build(key->getDate(key));\n')])])]),t("p",[e._v("6 写入外部存储")]),e._v(" "),t("p",[e._v("多级缓存的情况下，这个方法还是很实用的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("LoadingCache<String, Object> cache2 = Caffeine.newBuilder()\n    .writer(new CacheWriter<String, Object>() {\n        @Override public void write(String key, Object value) {\n            // 写入到外部存储\n        }\n        @Override public void delete(String key, Object value, RemovalCause cause) {\n            // 删除外部存储\n        }\n    })\n    .build(key -> function(key));\n")])])]),t("p",[e._v("7 统计")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Cache<String, Object> cache = Caffeine.newBuilder()\n    .maximumSize(10_000)\n    .recordStats()\n    .build();\n")])])]),t("p",[e._v("通过 Cache.stats() 返回一个CacheStats。CacheStats提供以下统计方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("hitRate(): 返回缓存命中率\nevictionCount(): 缓存回收数量\naverageLoadPenalty(): 加载新值的平均时间\n")])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("Caffeine Cache 可以说是站在巨人（Guava Cache）的肩膀上发展起来的新一代缓存框架，他有着比 Guava Cache 更好的性能。\n他的 api 跟 Guava 高度相似，使用过 Guava 的同学可以很顺利的切换到 Caffeine Cache。")])])}),[],!1,null,null,null);a.default=i.exports}}]);