(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{527:function(e,r,s){"use strict";s.r(r);var a=s(4),t=Object(a.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"redis-简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-简介"}},[e._v("#")]),e._v(" Redis 简介")]),e._v(" "),s("p",[s("em",[e._v("Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性（英语：Durability_database_systems）的键值对存储数据库 —— 维基百科")])]),e._v(" "),s("p",[e._v("随着微服务的普及，Redis 的使用也越来越普遍，比如分布式缓存、分布式锁、Session 存储\\共享等。\nSpring Boot 对 Redis 提供了很好的支持，基本实现了免配置开箱即用，当然 Spring Boot 也留给用户足够的自定义空间。")]),e._v(" "),s("h2",{attrs:{id:"redis-的两种-java-客户端：jedis-和-lettus"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-的两种-java-客户端：jedis-和-lettus"}},[e._v("#")]),e._v(" Redis 的两种 Java 客户端：jedis 和 lettus")]),e._v(" "),s("p",[e._v("Spring Boot 2.x 之前的版本默认客户端是 jedis，2.x 以及之后的版本默认客户端是 lettuce。")]),e._v(" "),s("h3",{attrs:{id:"pom-依赖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pom-依赖"}},[e._v("#")]),e._v(" pom 依赖")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("\x3c!--Redis--\x3e\n<dependency>    \n    <groupId>org.springframework.boot</groupId>    \n    <artifactId>spring-boot-starter-data-redis</artifactId>\n    \x3c!-- 默认的redis客户端是lettuce，想切换成jedis需要在这里排除lettuce包，然后引入jedis的依赖包即可--\x3e\n    \x3c!--<exclusions>--\x3e\n        \x3c!--<exclusion>--\x3e\n            \x3c!--<groupId>io.lettuce</groupId>--\x3e  \n            \x3c!--<artifactId>lettuce-core</artifactId>--\x3e   \n        \x3c!--</exclusion>--\x3e  \n    \x3c!--</exclusions>--\x3e\n</dependency>\n\n\x3c!--jedis客户端的依赖包--\x3e\n\x3c!--<dependency>--\x3e   \n    \x3c!--<groupId>redis.clients</groupId>--\x3e \n    \x3c!--<artifactId>jedis</artifactId>--\x3e\n\x3c!--</dependency>--\x3e\n")])])]),s("h3",{attrs:{id:"application-properties配置文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#application-properties配置文件"}},[e._v("#")]),e._v(" application.properties配置文件")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("################ Redis 基础配置 ############## \n# Redis数据库索引（默认为0） \nspring.redis.database=0 \n# Redis服务器地址 \nspring.redis.host=127.0.0.1 \n# Redis服务器连接端口 \nspring.redis.port=6379 \n# Redis服务器连接密码（默认为空） \nspring.redis.password=zwqh \n# 链接超时时间 单位 ms（毫秒） \nspring.redis.timeout=3000 \n################ Redis lettuce client线程池设置 ############## \n# 连接池最大连接数（使用负值表示没有限制） 默认 8 \nspring.redis.lettuce.pool.max-active=8 \n# 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1 \nspring.redis.lettuce.pool.max-wait=-1 \n# 连接池中的最大空闲连接 默认 8 \nspring.redis.lettuce.pool.max-idle=8 \n# 连接池中的最小空闲连接 默认 0 \nspring.redis.lettuce.pool.min-idle=0\n\n################ Redis jedis client线程池设置 ############## \nspring.redis.lettuce.pool.max-active=8 \nspring.redis.lettuce.pool.max-wait=-1 \nspring.redis.lettuce.pool.max-idle=8 \nspring.redis.lettuce.pool.min-idle=0\n")])])]),s("h3",{attrs:{id:"redistemplate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redistemplate"}},[e._v("#")]),e._v(" RedisTemplate")]),e._v(" "),s("p",[e._v("Spring Boot 提供了 RedisTemplate 来执行 Redis 操作。这是一个泛型类，默认实现只有 RedisTemplate<String,String> 类，这个类也是我们可直接使用的，\n如果需要存储其他的泛型 value，就必须自己定义一个 RedisTemplate。下面是一个通用的 RedisTemplate 配置：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Bean\npublic RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory connectionFactory) {   \n    RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();    \n    redisTemplate.setKeySerializer(new StringRedisSerializer());     \n    redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());    \n    redisTemplate.setConnectionFactory(connectionFactory);    \n    return redisTemplate;\n}\n")])])]),s("p",[e._v("ok，配置完这些我们就能在 Spring Boot 项目中愉快的使用 RedisTemplate 进行各种操作了。针对 Redis 的五种数据类型，\nRedisTemplate 提供了以下五个 API 来获取对应的操作入口。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("操作字符串：redisTemplate.opsForValue()\n操作 Hash：redisTemplate.opsForHash()\n操作 List：redisTemplate.opsForList()\n操作 Set：redisTemplate.opsForSet()\n操作 ZSet：redisTemplate.opsForZSet()\n")])])]),s("p",[e._v("API 都比较多，在此不一一列举。")]),e._v(" "),s("h2",{attrs:{id:"redis-分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-分布式锁"}},[e._v("#")]),e._v(" Redis 分布式锁")]),e._v(" "),s("p",[e._v("分布式锁不是简单的在 Redis 中设置一个 K、V 的事，它是一个复杂的问题，有很多方面的问题需要考虑，\n"),s("a",{attrs:{href:"http://www.redis.cn/articles/20181020004.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何优雅地用Redis实现分布式锁"),s("OutboundLink")],1),e._v(" 这篇文章非常详细的讲解了几种分布式锁实现方案，\n在这里我就不多作说明了。项目中很少会自己动手搞一个 Redis 分布式锁，使用 Redisson 开箱即用的分布式锁才是王道。\n关于 Redisson 的使用，后面再另外写一篇博客介绍。")]),e._v(" "),s("h2",{attrs:{id:"redis-分布式缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-分布式缓存"}},[e._v("#")]),e._v(" Redis 分布式缓存")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://blog.fengxiuge.top/2020/2020-10-20-spring-cache.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring 基于注释的缓存框架"),s("OutboundLink")],1),e._v("\n这篇博客已经很详细的讲解了 Spring 缓存框架的一些基础知识以及整合 Caffeine Cache 的一些用法。\n现在我使用 Redis 代替 Caffeine Cache 再来跑一下之前的测试方法。")]),e._v(" "),s("h3",{attrs:{id:"pom文件加入-spring-cache-依赖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pom文件加入-spring-cache-依赖"}},[e._v("#")]),e._v(" pom文件加入 Spring Cache 依赖")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("<dependency>  \n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n")])])]),s("h3",{attrs:{id:"配置-redistmapcachemanager"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置-redistmapcachemanager"}},[e._v("#")]),e._v(" 配置 RedistMapCacheManager")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('@Bean\n//@Qualifier("redisCacheManager")\npublic RedisCacheManager cacheManager(LettuceConnectionFactory connectionFactory) {    \n\nRedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofSeconds(5)); // 设置缓存有效期5秒   \nRedisCacheManager redisCacheManager = RedisCacheManager.builder(connectionFactory).cacheDefaults(redisCacheConfiguration).build();    \n\nreturn redisCacheManager;\n')])])]),s("h3",{attrs:{id:"创建测试-service-类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建测试-service-类"}},[e._v("#")]),e._v(" 创建测试 Service 类")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('package com.fxg.springboot.redis.service;\n\nimport com.fxg.springboot.redis.domain.User;import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;i\nmport org.springframework.cache.annotation.CacheConfig;\nimport org.springframework.cache.annotation.CacheEvict;\nimport org.springframework.cache.annotation.CachePut;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\n\n@Service\n//@CacheConfig(cacheManager = "redisCacheManager")\npublic class UserService { \n\n    private Logger logger = LoggerFactory.getLogger(this.getClass().getName());   \n\n    @Cacheable(value = "userCache",key = "#id")   \n    public User getUserById(Integer id) {         \n        logger.info("执行查询接口，id：{}",id);         \n        User user = new User();          \n        user.setId(id);           \n        user.setName("小灰灰");        \n        return user;     \n    }     \n    /**     \n    * 更新/保存    \n    * @param user   \n    */     \n    @CachePut(value = "userCache", key = "#user.id")  \n    public User saveUser(User user){       \n        //更新数据库        \n        logger.info("执行更新接口，user:{}",user.toString());    \n        return user;      \n    }     \n    /**     \n    * 删除      \n    * @param id      \n    */     \n    @CacheEvict(value = "userCache",key = "#id")  \n        public void deleteUser(Integer id){       \n        //删除数据库中数据           \n        logger.info("执行删除接口，id:{}",id);  \n    }\n}\n')])])]),s("h3",{attrs:{id:"创建测试类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建测试类"}},[e._v("#")]),e._v(" 创建测试类")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('package com.fxg.springboot.redis.tests;\n\nimport com.fxg.springboot.redis.domain.User;\nimport com.fxg.springboot.redis.service.UserService;import org.junit.jupiter.api.Test;\nimport org.slf4j.Logger;import org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.data.redis.cache.RedisCacheManager;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport java.io.Serializable;import java.util.concurrent.TimeUnit;\n\n@SpringBootTest\npublic class RedisCacheTest {   \n\n    private Logger logger = LoggerFactory.getLogger(this.getClass().getName());  \n\n    @Autowired       \n    private UserService userService;   \n\n    @Autowired    \n    private RedisCacheManager redisCacheManager;   \n\n    @Test     \n    public void test1() throws Exception {    \n        logger.info("第一次查询");    \n        User user1 = userService.getUserById(99);//第一次查询     \n        logger.info("第一次查询结果：{}", user1);      \n\n        logger.info("第二次查询");         \n        User user2 = userService.getUserById(99);//第二次查询   \n        logger.info("第二次查询结果：{}", user2);       \n\n        Thread.sleep(6000);//等待6秒，等缓存过期    \n\n        logger.info("缓存过期后再次查询");       \n        User user3 = userService.getUserById(99);//缓存过期后再次查询    \n        logger.info("缓存过期后再次查询结果：{}", user3);       \n\n        userService.saveUser(new User(99, "红太狼"));//更新缓存    \n\n        logger.info("更新缓存后查询");          \n        User user4 = userService.getUserById(99);//更新缓存后再次查询    \n        logger.info("更新缓存后再次查询结果：{}", user4);  \n\n        userService.deleteUser(99);//删除缓存        \n\n        logger.info("删除缓存后查询");        \n        User user5 = userService.getUserById(99);//删除缓存后再次查询     \n        logger.info("删除缓存后再次查询结果：{}",user5);          \n\n        logger.info(redisCacheManager.getCacheNames().toString());    \n        logger.info(redisCacheManager.toString());\n    }\n}\n')])])]),s("h3",{attrs:{id:"测试结果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#测试结果"}},[e._v("#")]),e._v(" 测试结果")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("2020-12-04 18:12:18.170 [main] INFO  c.f.s.redis.tests.RedisCacheTest - 第一次查询\n2020-12-04 18:12:21.650 [main] INFO  c.f.s.redis.service.UserService - 执行查询接口，id：99\n2020-12-04 18:12:21.719 [main] INFO  c.f.s.redis.tests.RedisCacheTest - 第一次查询结果：User{id=99, name='小灰灰'}\n2020-12-04 18:12:21.721 [main] INFO  c.f.s.redis.tests.RedisCacheTest - 第二次查询\n2020-12-04 18:12:21.771 [main] INFO  c.f.s.redis.tests.RedisCacheTest - 第二次查询结果：User{id=99, name='小灰灰'}\n2020-12-04 18:12:27.774 [main] INFO  c.f.s.redis.tests.RedisCacheTest - 缓存过期后再次查询\n2020-12-04 18:12:27.812 [main] INFO  c.f.s.redis.service.UserService - 执行查询接口，id：99\n2020-12-04 18:12:27.833 [main] INFO  c.f.s.redis.tests.RedisCacheTest - 缓存过期后再次查询结果：User{id=99, name='小灰灰'}\n2020-12-04 18:12:27.833 [main] INFO  c.f.s.redis.service.UserService - 执行更新接口，user:User{id=99, name='红太狼'}\n2020-12-04 18:12:27.880 [main] INFO  c.f.s.redis.tests.RedisCacheTest - 更新缓存后查询\n2020-12-04 18:12:27.925 [main] INFO  c.f.s.redis.tests.RedisCacheTest - 更新缓存后再次查询结果：User{id=99, name='红太狼'}\n2020-12-04 18:12:27.925 [main] INFO  c.f.s.redis.service.UserService - 执行删除接口，id:99\n2020-12-04 18:12:27.969 [main] INFO  c.f.s.redis.tests.RedisCacheTest - 删除缓存后查询\n2020-12-04 18:12:27.995 [main] INFO  c.f.s.redis.service.UserService - 执行查询接口，id：99\n2020-12-04 18:12:28.024 [main] INFO  c.f.s.redis.tests.RedisCacheTest - 删除缓存后再次查询结果：User{id=99, name='小灰灰'}\n2020-12-04 18:12:28.025 [main] INFO  c.f.s.redis.tests.RedisCacheTest - [userCache]\n2020-12-04 18:12:28.026 [main] INFO  c.f.s.redis.tests.RedisCacheTest - org.springframework.data.redis.cache.RedisCacheManager@798deee8\n")])])]),s("p",[e._v("从运行结果可以看出")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("* 第一次查询走了查询接口，第二次查询时缓存生效所以没有走查询接口。\n\n* 执行更新接口后再进行查询，没有走查询接口，且查询到的数据是更新后的，说明更新接口的结果也被更新到缓存中了。\n\n* 等缓存过期后再进行查询，走了查询接口，说明 Caffeine 的定时驱逐策略生效。\n\n* 执行删除接口后再进行查询，走了查询接口，说明删除时也同时删除了缓存中的数据。\n\n* Cache Manager 已经由默认情况下的 ConcurrentMapCacheManager 变成了 RedisCacheManager。\n")])])]),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),s("p",[e._v("测试代码已上传 "),s("a",{attrs:{href:"https://github.com/yueyakun2017/my-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitHub"),s("OutboundLink")],1),e._v("。")])])}),[],!1,null,null,null);r.default=t.exports}}]);