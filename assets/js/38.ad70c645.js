(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{521:function(e,t,a){"use strict";a.r(t);var s=a(4),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("一直想给"),a("a",{attrs:{href:"https://house.fengxiuge.top",target:"_blank",rel:"noopener noreferrer"}},[e._v("小链家"),a("OutboundLink")],1),e._v("做接口安全相关的功能，比如：请求防篡改、防重放攻击、请求体加密、返回结果加密。\n正好这两天有空，就付诸行动了。")]),e._v(" "),a("h2",{attrs:{id:"要解决的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#要解决的问题"}},[e._v("#")]),e._v(" 要解决的问题")]),e._v(" "),a("p",[e._v("我希望 API 能实现这样四个安全功能：请求防篡改、防重放攻击、请求体加密、返回结果加密。")]),e._v(" "),a("p",[e._v("而解决这四个问题一般采用 "),a("strong",[e._v("API 签名")]),e._v("和 "),a("strong",[e._v("API 参数加密")]),e._v("的方式，关于签名和加密的原理在这里不再讲了，网上一搜一大把。")]),e._v(" "),a("h2",{attrs:{id:"技术选型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#技术选型"}},[e._v("#")]),e._v(" 技术选型")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("签名算法采用 MD5 摘要算法。之所以没采用更安全的 SHA256 是因为一来 MD5 速度更快，二来对小链家来说 MD5 足够安全了。")])]),e._v(" "),a("li",[a("p",[e._v("签名算法采用 RAS 和 AES 组合的方式。RAS 只是用来加密 AES 秘钥，这样既避免了 AES 对称加密秘钥有泄露风险的问题，\n又解决了 RAS 加解密大量数据时速度慢的问题。")])])]),e._v(" "),a("h2",{attrs:{id:"具体思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具体思路"}},[e._v("#")]),e._v(" 具体思路")]),e._v(" "),a("h3",{attrs:{id:"生成-ras-公钥和私钥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成-ras-公钥和私钥"}},[e._v("#")]),e._v(" 生成 RAS 公钥和私钥")]),e._v(" "),a("p",[e._v("生成一对公钥和私钥，公钥交给前端，私钥后端自己保存。")]),e._v(" "),a("h3",{attrs:{id:"前端发起请求的步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端发起请求的步骤"}},[e._v("#")]),e._v(" 前端发起请求的步骤")]),e._v(" "),a("ol",[a("li",[e._v("每次请求前，前端生成一个 AES 秘钥（aesKey），然后用 aesKey 加密 body 得到 encryptedBody，用 encryptedBody 替换原来的明文 body；")]),e._v(" "),a("li",[e._v("将 requestParam、encryptedBody、aesKey、timestamp（时间戳）、随机数（nonce） 做签名处理，得到签名值 sign；")]),e._v(" "),a("li",[e._v("用 RSA 公钥加密 aesKey，得到 encryptedAesKey；")]),e._v(" "),a("li",[e._v("请求头中放入 sign、timestamp、nonce 和 encryptedAesKey，发起请求。")])]),e._v(" "),a("h3",{attrs:{id:"后端拦截器验证签名逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后端拦截器验证签名逻辑"}},[e._v("#")]),e._v(" 后端拦截器验证签名逻辑")]),e._v(" "),a("ol",[a("li",[e._v("用私钥解密 encryptedAesKey 得到 aesKey ；")]),e._v(" "),a("li",[e._v("校验 timestamp 是否在允许的超时范围内，不在范围内就拒绝掉；")]),e._v(" "),a("li",[e._v("查询 timestamp + nonce 在 redis 中是否存在，存在就拒绝掉；（结合第4步，防止重放攻击）；")]),e._v(" "),a("li",[e._v("如果不存在就将 timestamp 和 aesKey 拼接然后存入 redis，设置过期时间30秒；（结合第3步，防止重放攻击）；")]),e._v(" "),a("li",[e._v("将收到的 requestParam、encryptedBody、aesKey、timestamp 做签名处理，校验签名结果与请求头中的 sign 是否一致，不一致就拒绝掉；")]),e._v(" "),a("li",[e._v("将解密出来的 aesKey 放入 ThreadLocal 向后传递。")])]),e._v(" "),a("h3",{attrs:{id:"后端解密-body"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后端解密-body"}},[e._v("#")]),e._v(" 后端解密 body")]),e._v(" "),a("p",[e._v("采用 RequestBodyAdvice 的方式在请求进入 Controller 方法之前解密 body")]),e._v(" "),a("ol",[a("li",[e._v("实现 RequestBodyAdvice 接口，从 ThreadLocal 取出 aesKey，解密出加密的 body。")])]),e._v(" "),a("h3",{attrs:{id:"后端加密-response"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后端加密-response"}},[e._v("#")]),e._v(" 后端加密 response")]),e._v(" "),a("p",[e._v("采用 ResponseBodyAdvice 的方式在 Controller 方法返回后对 Response 中的数据进行加密")]),e._v(" "),a("ol",[a("li",[e._v("实现 ResponseBodyAdvice 接口，从 ThreadLocal 取出 aesKey，加密返回值。")])]),e._v(" "),a("h3",{attrs:{id:"前端解密返回结果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端解密返回结果"}},[e._v("#")]),e._v(" 前端解密返回结果")]),e._v(" "),a("ol",[a("li",[e._v("前端接收到返回结果后用之前请求发起时生成的的 aesKey 解密返回结果")])]),e._v(" "),a("h2",{attrs:{id:"要思考的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#要思考的问题"}},[e._v("#")]),e._v(" 要思考的问题")]),e._v(" "),a("ol",[a("li",[e._v("前端需要保存 RSA 公钥，怎么保存安全？")]),e._v(" "),a("li",[e._v("前端发起请求后 aesKey 存在哪里才能在结果返回时拿到？")])])])}),[],!1,null,null,null);t.default=r.exports}}]);