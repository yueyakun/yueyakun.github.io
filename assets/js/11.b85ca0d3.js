(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{497:function(t,a,e){"use strict";e.r(a);var s=e(4),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"问题：这两个都能注入bean，有啥子区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题：这两个都能注入bean，有啥子区别？"}},[t._v("#")]),t._v(" 问题：这两个都能注入Bean，有啥子区别？")]),t._v(" "),e("p",[t._v("@Autowired是我常用的注解，@Resource不常用，他们之间的异同点一直很模糊。今天抽空面向搜索引擎把他们的常用姿势给查了下，记录如下：")]),t._v(" "),e("h2",{attrs:{id:"相同点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[t._v("#")]),t._v(" 相同点")]),t._v(" "),e("ul",[e("li",[t._v("都能注入bean（这是废话）")]),t._v(" "),e("li",[t._v("都能标注在字段上或者setter方法上")])]),t._v(" "),e("h2",{attrs:{id:"不同点-autowired-默认按照类型装配-resource-默认是按照名称装配"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不同点-autowired-默认按照类型装配-resource-默认是按照名称装配"}},[t._v("#")]),t._v(" 不同点:@Autowired 默认按照类型装配 @Resource 默认是按照名称装配")]),t._v(" "),e("ul",[e("li",[t._v("@Autowire默认按类型装配，要求被注入的对象必须存在，如果允许不存在要将required属性设置为false。结合@Qualifier使用也可以实现按类型装配，用例如下：")])]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Autowired")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("required"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    \n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FileService")]),t._v(" fileService"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Autowired")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Qualifier")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"userService"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    \n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UserService")]),t._v(" userService"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ul",[e("li",[t._v("@Autowired实现:")])]),t._v(" "),e("ol",[e("li",[e("p",[t._v("注解驱动配置会向spring容器中注册AutowiredAnnotationBeanPostProcessor")])]),t._v(" "),e("li",[e("p",[t._v("当 Spring 容器启动时，AutowiredAnnotationBeanPostProcessor 将扫描 Spring 容器中所有 Bean，当发现 Bean 中拥有 @Autowired 注释时就找到和其匹配（默认按类型匹配）的 Bean，并注入到对应的地方中去。")])])]),t._v(" "),e("ul",[e("li",[t._v("@Resource默认按照名称装配，可以通过name属性指定名称。也可以按照类型注入，通过type属性指定")])]),t._v(" "),e("ol",[e("li",[e("p",[t._v("如果没有指定name属性，当注解写在字段上时，默认取字段名，按照名称查找。")])]),t._v(" "),e("li",[e("p",[t._v("当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。")])]),t._v(" "),e("li",[e("p",[t._v("当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。")])])]),t._v(" "),e("ul",[e("li",[t._v("@Resource装配顺序")])]),t._v(" "),e("ol",[e("li",[t._v("如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常")]),t._v(" "),e("li",[t._v("如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常")]),t._v(" "),e("li",[t._v("如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常")]),t._v(" "),e("li",[t._v("如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；")])]),t._v(" "),e("ul",[e("li",[t._v("另外，依赖注入是Spring的核心之一，关于他的原理和源码分析后面日志中在慢慢补充。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);