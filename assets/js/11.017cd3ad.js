(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{496:function(t,e,a){"use strict";a.r(e);var s=a(4),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"问题：这两个都能注入bean，有啥子区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题：这两个都能注入bean，有啥子区别？"}},[t._v("#")]),t._v(" 问题：这两个都能注入Bean，有啥子区别？")]),t._v(" "),a("p",[t._v("@Autowired 是我常用的注解，@Resource 不常用，他们之间的异同点一直很模糊。今天抽空面向搜索引擎把他们的常用姿势给查了下，记录如下：")]),t._v(" "),a("h2",{attrs:{id:"相同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[t._v("#")]),t._v(" 相同点")]),t._v(" "),a("ul",[a("li",[t._v("都能注入bean（这是废话）")]),t._v(" "),a("li",[t._v("都能标注在字段上或者setter方法上")])]),t._v(" "),a("h2",{attrs:{id:"不同点：-autowired-默认按照类型装配-resource-默认是按照名称装配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同点：-autowired-默认按照类型装配-resource-默认是按照名称装配"}},[t._v("#")]),t._v(" 不同点：@Autowired 默认按照类型装配 @Resource 默认是按照名称装配")]),t._v(" "),a("ul",[a("li",[t._v("@Autowire 默认按类型装配，要求被注入的对象必须存在，如果允许不存在要将 required 属性设置为 false。结合 @Qualifier 使用也可以实现按名称装配，用例如下：")])]),t._v(" "),a("div",{staticClass:"language-Java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Autowired")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("required"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    \n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FileService")]),t._v(" fileService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Autowired")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Qualifier")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"userService"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    \n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UserService")]),t._v(" userService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[t._v("@Autowired 实现:")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("注解驱动配置会向 spring 容器中注册 AutowiredAnnotationBeanPostProcessor")])]),t._v(" "),a("li",[a("p",[t._v("当 Spring 容器启动时，AutowiredAnnotationBeanPostProcessor 将扫描 Spring 容器中所有 Bean，当发现 Bean 中拥有 @Autowired 注释时就找到和其匹配（默认按类型匹配）的 Bean，并注入到对应的地方中去。")])])]),t._v(" "),a("ul",[a("li",[t._v("@Resource 默认按照名称装配，可以通过 name 属性指定名称。也可以按照类型注入，通过 type 属性指定")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("如果没有指定 name 属性，当注解写在字段上时，默认取字段名，按照名称查找。")])]),t._v(" "),a("li",[a("p",[t._v("当注解标注在属性的 setter 方法上，即默认取属性名作为 bean 名称寻找依赖对象。另外，加在 setter 方法上可以实现给组件类的静态属性注入 Bean 的目的。")])]),t._v(" "),a("li",[a("p",[t._v("当找不到与名称匹配的 bean 时才按照类型进行装配。但是需要注意的是，如果 name 属性一旦指定，就只会按照名称进行装配。")])])]),t._v(" "),a("ul",[a("li",[t._v("@Resource 装配顺序")])]),t._v(" "),a("ol",[a("li",[t._v("如果同时指定了 name 和 type，则从 Spring 上下文中找到唯一匹配的 bean 进行装配，找不到则抛出异常")]),t._v(" "),a("li",[t._v("如果指定了 name，则从上下文中查找名称（id）匹配的 bean 进行装配，找不到则抛出异常")]),t._v(" "),a("li",[t._v("如果指定了 type，则从上下文中找到类型匹配的唯一 bean 进行装配，找不到或者找到多个，都会抛出异常")]),t._v(" "),a("li",[t._v("如果既没有指定 name，又没有指定 type，则自动按照 byName 方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；")])]),t._v(" "),a("ul",[a("li",[t._v("另外，依赖注入是 Spring 的核心之一，关于他的原理和源码分析后面日志中在慢慢补充。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);