(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{511:function(a,t,r){"use strict";r.r(t);var e=r(4),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("p",[a._v("关于 Java 8 的 Stream 流式编程内容较多，所以日志分为三部分：")]),a._v(" "),r("ol",[r("li",[r("RouterLink",{attrs:{to:"/2020/2020-08-20-java8-stream-1.html"}},[a._v("常用的 Stream API")]),a._v("：对于新东西我一般先学会用，然后再慢慢的深入了解。")],1),a._v(" "),r("li",[r("RouterLink",{attrs:{to:"/2020/2020-08-27-java8-stream-2.html"}},[a._v("关于 Straem 的一些总结")]),a._v("：熟练使用之后就该总结一下了。")],1),a._v(" "),r("li",[r("RouterLink",{attrs:{to:"/2020/2020-09-28-java8-stream-3.html"}},[a._v("Stream 的原理")]),a._v("：知道工具的原理才能更好的使用工具。")],1)]),a._v(" "),r("p",[a._v("这篇是该日志的第二部分，也就是一些关于 Stream 知识点的总结。")]),a._v(" "),r("h2",{attrs:{id:"概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),r("p",[a._v("Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。")]),a._v(" "),r("h2",{attrs:{id:"什么是流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是流"}},[a._v("#")]),a._v(" 什么是流")]),a._v(" "),r("h3",{attrs:{id:"流的特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流的特点"}},[a._v("#")]),a._v(" 流的特点")]),a._v(" "),r("ol",[r("li",[a._v("无存储：")])]),a._v(" "),r("p",[a._v("Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。")]),a._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[a._v("惰性执行：")])]),a._v(" "),r("p",[a._v("对一个 Stream 的一系列操作是一个整体，排在前面的中间（Intermediate）操作和排在最后的结束（Terminal）操作是一起执行的。可以看做在最后的终止操作之前，前面的中间操作都是惰性执行的。")]),a._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[a._v("消费性：")])]),a._v(" "),r("p",[a._v("Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。")]),a._v(" "),r("h3",{attrs:{id:"java-8-提供的流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-8-提供的流"}},[a._v("#")]),a._v(" Java 8 提供的流")]),a._v(" "),r("p",[a._v("Java 8 提供了四种流，Stream、IntStream、LongStream、DoubleStream。后三种流是包装类型的 Stream，当然我们也可以用 Stream"),r("Integer",[a._v("、Stream"),r("Long",[a._v("、Stream"),r("Double",[a._v("，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。")])],1)],1)],1),a._v(" "),r("h3",{attrs:{id:"流的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流的作用"}},[a._v("#")]),a._v(" 流的作用")]),a._v(" "),r("p",[a._v("对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。")]),a._v(" "),r("h3",{attrs:{id:"得到-stream-的途径"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#得到-stream-的途径"}},[a._v("#")]),a._v(" 得到 Stream 的途径")]),a._v(" "),r("ol",[r("li",[a._v("从 Collection 和数组：")])]),a._v(" "),r("p",[a._v("Collection.stream()")]),a._v(" "),r("p",[a._v("Collection.parallelStream()")]),a._v(" "),r("p",[a._v("Array.stream(T array)")]),a._v(" "),r("p",[a._v("Stream.of(T array)")]),a._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[a._v("从 BufferedReader：")])]),a._v(" "),r("p",[a._v("java.io.BufferedReader.lines()")]),a._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[a._v("静态工厂：")])]),a._v(" "),r("p",[a._v("java.util.stream.IntStream.range()")]),a._v(" "),r("p",[a._v("java.nio.file.Files.walk()")]),a._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[a._v("自己构建")])]),a._v(" "),r("p",[a._v("java.util.Spliterator")]),a._v(" "),r("ol",{attrs:{start:"5"}},[r("li",[a._v("其它")])]),a._v(" "),r("p",[a._v("Random.ints()")]),a._v(" "),r("p",[a._v("BitSet.stream()")]),a._v(" "),r("p",[a._v("Pattern.splitAsStream(java.lang.CharSequence)")]),a._v(" "),r("p",[a._v("JarFile.stream()")]),a._v(" "),r("h2",{attrs:{id:"流的操作分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流的操作分类"}},[a._v("#")]),a._v(" 流的操作分类")]),a._v(" "),r("p",[r("img",{attrs:{src:"/posts/2020-08-27-java8-stream-2/01.png",alt:""}})]),a._v(" "),r("p",[a._v("Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。")]),a._v(" "),r("h3",{attrs:{id:"中间操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中间操作"}},[a._v("#")]),a._v(" 中间操作")]),a._v(" "),r("p",[a._v("中间操作又可以分为无状态的和有状态的，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果。")]),a._v(" "),r("h3",{attrs:{id:"结束操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结束操作"}},[a._v("#")]),a._v(" 结束操作")]),a._v(" "),r("p",[a._v("结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。")]),a._v(" "),r("h2",{attrs:{id:"stream-的性能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#stream-的性能"}},[a._v("#")]),a._v(" Stream 的性能")]),a._v(" "),r("p",[a._v("懒得自己写代码测试了，想了解 Stream API 的性能如何，可以查看一位大佬的博客："),r("a",{attrs:{href:"https://www.cnblogs.com/carpenterlee/p/6675568.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java Stream API性能测试"),r("OutboundLink")],1)]),a._v(" "),r("p",[a._v("根据这位博主的测试结合我们以往使用经验，可以得出结论：")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("简单的集合遍历操作，如对性能不敏感的地方推荐使用 Stream API，简化代码。对性能敏感，则推荐手动遍历。")])]),a._v(" "),r("li",[r("p",[a._v("复杂的集合归纳（reduce）、收集（collect）操作，推荐使用 Stream API，性能有保障又能简化代码，真香！")])]),a._v(" "),r("li",[r("p",[a._v("大数据量的集合操作，推荐使用并行 Stream，可以简单无脑地实现并发编程，提高性能。")])])])])}),[],!1,null,null,null);t.default=v.exports}}]);