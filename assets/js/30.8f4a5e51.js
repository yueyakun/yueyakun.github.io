(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{513:function(e,t,n){"use strict";n.r(t);var a=n(4),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("关于 Java 8 的 Stream 流式编程内容较多，所以日志分为三部分：")]),e._v(" "),n("ol",[n("li",[n("RouterLink",{attrs:{to:"/2020/2020-08-20-java8-stream-1.html"}},[e._v("常用的 Stream API")]),e._v("：对于新东西我一般先学会用，然后再慢慢的深入了解。")],1),e._v(" "),n("li",[n("RouterLink",{attrs:{to:"/2020/2020-08-27-java8-stream-2.html"}},[e._v("关于 Straem 的一些总结")]),e._v("：熟练使用之后就该总结一下了。")],1),e._v(" "),n("li",[n("RouterLink",{attrs:{to:"/2020/2020-09-28-java8-stream-3.html"}},[e._v("Stream 的原理")]),e._v("：知道工具的原理才能更好的使用工具。")],1)]),e._v(" "),n("p",[e._v("这篇是该日志的第三部分，也就是一些关于 Stream 背后原理的总结。")]),e._v(" "),n("h2",{attrs:{id:"流是怎么执行的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#流是怎么执行的"}},[e._v("#")]),e._v(" 流是怎么执行的")]),e._v(" "),n("p",[e._v("首先我们先思考一个问题，对一个流进行多步操作时，每一步是怎么执行的？每一步都是把流中的元素都循环一遍吗？")]),e._v(" "),n("p",[e._v("我们先看一段示例代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('    String[] strs = new String[]{"AAA","bbbb","ccc","DDddD"};\n    OptionalInt max = Arrays.stream(strs)\n            .peek(System.out::println)\n            .filter(s -> s.length() > 3)\n            .peek(System.out::println)\n            .mapToInt(String::length)\n            .peek(System.out::println)\n            .max();\n    System.out.printf("字符串最大长度是：%d%n", max.getAsInt());\n')])])]),n("p",[e._v("这段代码的逻辑是：")]),e._v(" "),n("ol",[n("li",[e._v("对一个字符串数组进行遍历打印，")]),e._v(" "),n("li",[e._v("过滤出长度大于 3 的字符串")]),e._v(" "),n("li",[e._v("再打印一遍过滤后的数组")]),e._v(" "),n("li",[e._v("将过滤后的数组转换成长度组成的int数组")]),e._v(" "),n("li",[e._v("提取出这个 int 数组的对大值")])]),e._v(" "),n("p",[e._v("执行结果如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("AAA\nbbbb\nbbbb\n4\nccc\nDDddD\nDDddD\n5\n字符串最大长度是：5\n")])])]),n("p",[e._v("从执行结果来看，很明显中单步操作并不是把整个数组遍历一遍然后再执行下一步操作，而是数组中的每个元素依次通过每一步操作。\n这也印证了前一篇中总结的流的特点：只遍历一遍。\n想想也是啊，如果每一步操作都要遍历整个数组，那一系列操作下来要遍历 n 遍数组，性能肯定无法接受。")]),e._v(" "),n("p",[e._v("总结一下就是，对流的操作像是一个通道，每一步操作都是这个通道上的一节管道（Pipeline），流中的每一个元素依次通过管道，最后出来的就是最终的结果。\n每节管道就叫 Stream Pipelines。")]),e._v(" "),n("h2",{attrs:{id:"stream-pipelines"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#stream-pipelines"}},[e._v("#")]),e._v(" Stream Pipelines")]),e._v(" "),n("p",[e._v("把对流的操作抽象成 Pipeline 就会有一下几个问题：")]),e._v(" "),n("h3",{attrs:{id:"每一步操作是怎么封装成一节管道（pipeline）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#每一步操作是怎么封装成一节管道（pipeline）"}},[e._v("#")]),e._v(" 每一步操作是怎么封装成一节管道（Pipeline）")]),e._v(" "),n("p",[e._v("下面这张图是跟 Pipeline 相关的接口和类的继承关系图，还有 IntPipeline, LongPipeline, DoublePipeline 没在图中画出，\n这三个类专门为三种基本类型（不是包装类型）而定制的，跟 ReferencePipeline 是并列关系。\nHead用于表示第一个 Pipeline，即调用调用诸如Collection.stream()方法产生的 Pipeline，\n很显然这个 Pipeline 里不包含任何操作；StatelessOp 和 StatefulOp 分别表示无状态和有状态的 Pipeline，\n对应于无状态和有状态的中间操作。")]),e._v(" "),n("p",[n("img",{attrs:{src:"/posts/2020/2020-09-28-java8-stream-3-01.png",alt:""}})]),e._v(" "),n("h3",{attrs:{id:"管道的操作怎么串联起来"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#管道的操作怎么串联起来"}},[e._v("#")]),e._v(" 管道的操作怎么串联起来")]),e._v(" "),n("p",[e._v("每一个 Pipeline 的关联方式类似一个双向连表，由于每个 Pipeline 都记录了前一个 Pipeline 和本次的操作以及回调函数，\n依靠这种结构就能建立起对数据源的所有操作。而把这些 Pipeline 关联起来的一个关键接口就是 java.util.stream.Sink 接口。")]),e._v(" "),n("p",[n("img",{attrs:{src:"/posts/2020/2020-09-28-java8-stream-3-02.png",alt:""}})]),e._v(" "),n("p",[e._v("Sink 接口有这样四个方法：")]),e._v(" "),n("p",[e._v("begin(long size)：开始遍历元素之前调用该方法，通知 Sink 做好准备。")]),e._v(" "),n("p",[e._v("end()：所有元素遍历完成之后调用，通知 Sink 没有更多的元素了。")]),e._v(" "),n("p",[e._v("cancellationRequested()：是否可以结束操作，可以让短路操作尽早结束。")]),e._v(" "),n("p",[e._v("accept(T t)：遍历元素时调用，接受一个待处理元素，并对元素进行处理。\nPipeline 把自己包含的操作和回调方法封装到该方法里，前一个 Pipeline 只需要调用当前 Pipeline 的 accept(T t)方法就行了。")]),e._v(" "),n("p",[e._v("有了 Sink 接口，Pipeline 之间的串联就很简单了，前一个 Pipeline 再执行完自己的 accept 方法后执行后一个 Pipeline 的 accept 方法就行了，\n不用去关心后一个 Pipeline 是怎么实现的。")]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("Stream API 架构是想当复杂的，理解它的基本原理有利于我们写出更高效的代码。")])])}),[],!1,null,null,null);t.default=i.exports}}]);