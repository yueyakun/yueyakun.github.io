(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{506:function(t,a,s){"use strict";s.r(a);var e=s(4),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("先行发生（Happens-Before）的原则是 Java 内存模型（JMM）中非常重要的一个原则，是判断程序是否线程安全的依据。从JDK 5 开始，JMM 就使用 happens-before 的概念来阐述多线程之间的内存可见性。")]),t._v(" "),s("h2",{attrs:{id:"jmm-的-happens-before-规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm-的-happens-before-规则"}},[t._v("#")]),t._v(" JMM 的 Happens-Before 规则")]),t._v(" "),s("blockquote",[s("ol",[s("li",[t._v("程序次序规则（Program Order Rule）")])]),t._v(" "),s("p",[t._v("在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("管程锁定规则（Monitor Lock Rule）")])]),t._v(" "),s("p",[t._v("一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。")]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("volatile变量规则（Volatile Variable Rule）")])]),t._v(" "),s("p",[t._v("对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。")]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[t._v("线程启动规则（Thread Start Rule）")])]),t._v(" "),s("p",[t._v("Thread对象的start()方法先行发生于此线程的每一个动作。")]),t._v(" "),s("ol",{attrs:{start:"5"}},[s("li",[t._v("线程终止规则（Thread Termination Rule）")])]),t._v(" "),s("p",[t._v("线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。")]),t._v(" "),s("ol",{attrs:{start:"6"}},[s("li",[t._v("线程中断规则（Thread Interruption Rule）")])]),t._v(" "),s("p",[t._v("对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。")]),t._v(" "),s("ol",{attrs:{start:"7"}},[s("li",[t._v("对象终结规则（Finalizer Rule）")])]),t._v(" "),s("p",[t._v("一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。")]),t._v(" "),s("ol",{attrs:{start:"8"}},[s("li",[t._v("传递性（Transitivity）")])]),t._v(" "),s("p",[t._v("如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。")])]),t._v(" "),s("p",[t._v("如果两个操作不存在上述任一一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序。如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的。")]),t._v(" "),s("h2",{attrs:{id:"先行发生原则的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#先行发生原则的使用"}},[t._v("#")]),t._v(" 先行发生原则的使用")]),t._v(" "),s("div",{staticClass:"language-Java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" value "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\npubilc "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("假如有 A、B 两个线程，线程 A 先调 set(1) 方法，然后线程 B 调用 get 方法，那么线程 B 拿到的值是什么？")]),t._v(" "),s("p",[t._v("我们逐条分析先行发生原则：")]),t._v(" "),s("ul",[s("li",[t._v("有 A、B 两个线程，所以不符合‘程序次序规则’")]),t._v(" "),s("li",[t._v("没有加锁，所以不符‘合锁定规则’")]),t._v(" "),s("li",[t._v("变量没有 volatile 修饰，所以不符合‘volatile 变量规则’")])]),t._v(" "),s("p",[t._v("剩余5条规则更是不沾边，尽管管线程 A 在操作时间上先于线程 B，但是并不能确定线程 B 的返回结果。也就是说不是线程安全的。")]),t._v(" "),s("h2",{attrs:{id:"时间先后顺序与先行发生原则之间没有因果关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间先后顺序与先行发生原则之间没有因果关系"}},[t._v("#")]),t._v(" 时间先后顺序与先行发生原则之间没有因果关系")]),t._v(" "),s("p",[t._v("通过上面的例子，我们已经知道作‘时间上的先发生’不代表这个操作会是‘先行发生’。那如果一个操作‘先行发生’，是否就能推导出这个操作必定是‘时间上的先发生’呢？答案也是否定的，通过下面这个例子可以说明。")]),t._v(" "),s("div",{staticClass:"language-Java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//以下代码在同一线程中执行")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("；"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//操作a")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("；"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//操作b")]),t._v("\n")])])]),s("p",[t._v("根据程序次序规则，a 先行发生于 b，但是由于指令重排，b 很有可能被处理器先执行。这没有影响先行发生原则的正确性，因为我们在这条线程之中没有办法感知到这一点。")]),t._v(" "),s("p",[t._v("上面两个例子综合起来证明了一个结论：时间先后顺序与先行发生原则之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准。")]),t._v(" "),s("p",[t._v("本文是《深入理解Java虚拟机-第三版》第12章-第三节-第六小节的一篇读书笔记，建议阅读原文。")])])}),[],!1,null,null,null);a.default=r.exports}}]);